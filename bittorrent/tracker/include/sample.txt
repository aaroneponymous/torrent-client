// =============================================================
// bittorrent/tracker — Initial implementation (steps 1–6)
// - Public types & interfaces
// - Compact peer parsing utils
// - HTTP tracker client (BEP 3/7) using libcurl (now via mockable IHttpClient)
// - Endpoint/tier scheduling
// - TrackerManager skeleton w/ worker loop & announce() and peer callback
// - Minimal CMake snippet
// - NEW: IHttpClient abstraction + libcurl impl, unit tests (Catch2), TorrentSession wiring hook
//
// Files are delineated with `//// file:` markers for easy split.
// Target: C++20 (or C++17 ok if you drop std::jthread)
// =============================================================

//// file: include/bittorrent/tracker/expected.hpp
#pragma once
#include <optional>
#include <string>

namespace bittorrent::tracker {

struct Error {
  std::string message;
};

template <typename T>
struct Expected {
  std::optional<T> value;
  std::optional<Error> error;

  static Expected success(T v) {
    Expected e; e.value = std::move(v); return e;
  }
  static Expected failure(std::string msg) {
    Expected e; e.error = Error{std::move(msg)}; return e;
  }
  bool has_value() const { return value.has_value(); }
  T& get() { return *value; }
  const T& get() const { return *value; }
};

template <>
struct Expected<void> {
  std::optional<Error> error;
  static Expected success() { return {}; }
  static Expected failure(std::string msg) { Expected e; e.error = Error{std::move(msg)}; return e; }
  bool has_value() const { return !error.has_value(); }
};

} // namespace bittorrent::tracker


//// file: include/bittorrent/tracker/types.hpp
#pragma once
#include <array>
#include <cstdint>
#include <optional>
#include <string>
#include <string_view>
#include <vector>
#include <compare>

namespace bittorrent::tracker {

enum class AnnounceEvent { none, started, completed, stopped };

enum class Scheme { http, https, udp };

struct InfoHash {
  std::array<std::uint8_t,20> bytes{};
  std::string toHex() const;
  auto operator<=>(const InfoHash&) const = default;
};

struct PeerID {
  std::array<std::uint8_t,20> bytes{};
};

struct PeerAddr {
  std::string ip;     // dotted or RFC5952
  std::uint16_t port{0};
  std::optional<std::array<std::uint8_t,20>> peerId; // rarely present w/ non-compact
};

struct AnnounceRequest {
  InfoHash infoHash;
  PeerID   peerId;
  std::uint16_t port{6881};
  std::uint64_t uploaded{0};
  std::uint64_t downloaded{0};
  std::uint64_t left{0};
  AnnounceEvent event{AnnounceEvent::none};
  std::uint32_t numwant{50};
  std::uint32_t key{0};
  bool compact{true};
  bool no_peer_id{true};
  std::optional<std::string> ipv6;
  std::optional<std::string> trackerId;
};

struct AnnounceResponse {
  std::uint32_t interval{1800};
  std::optional<std::uint32_t> minInterval;
  std::uint32_t complete{0};   // seeders
  std::uint32_t incomplete{0}; // leechers
  std::vector<PeerAddr> peers;
  std::optional<std::string> warning;
  std::optional<std::string> trackerId;
};

struct ScrapeStats {
  std::uint32_t complete{0};
  std::uint32_t downloaded{0};
  std::uint32_t incomplete{0};
  std::optional<std::string> name;
};

} // namespace bittorrent::tracker


//// file: src/bittorrent/tracker/types.cpp
#include <sstream>
#include <iomanip>
#include <cctype>
#include <algorithm>
#include "bittorrent/tracker/types.hpp"

namespace bittorrent::tracker {

std::string InfoHash::toHex() const {
  std::ostringstream oss;
  for (auto b : bytes) {
    oss << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(b);
  }
  return oss.str();
}

} // namespace bittorrent::tracker


//// file: include/bittorrent/tracker/iclient.hpp
#pragma once
#include <map>
#include <vector>
#include "bittorrent/tracker/types.hpp"
#include "bittorrent/tracker/expected.hpp"

namespace bittorrent::tracker {

struct ITrackerClient {
  virtual ~ITrackerClient() = default;
  virtual Expected<AnnounceResponse> announce(const AnnounceRequest& req, const std::string& announceUrl) = 0;
  virtual Expected<std::map<InfoHash, ScrapeStats>> scrape(const std::vector<InfoHash>& hashes,
                                                           const std::string& scrapeUrl) = 0;
};

} // namespace bittorrent::tracker


//// file: include/bittorrent/tracker/http_client.hpp
#pragma once
#include <string>
#include "bittorrent/tracker/expected.hpp"

namespace bittorrent::tracker {

struct HttpResponse { int status{0}; std::string body; };

struct IHttpClient {
  virtual ~IHttpClient() = default;
  virtual Expected<HttpResponse> get(const std::string& url, int connectTimeoutSec, int transferTimeoutSec, bool followRedirects) = 0;
};

} // namespace bittorrent::tracker


//// file: src/bittorrent/tracker/http_client_curl.cpp
#include <curl/curl.h>
#include <string>
#include "bittorrent/tracker/http_client.hpp"

namespace bittorrent::tracker {
namespace { size_t cb(void* c,size_t s,size_t n,void* u){auto r=s*n; static_cast<std::string*>(u)->append((char*)c,r); return r;} }

class HttpClientCurl : public IHttpClient {
public:
  HttpClientCurl(){ curl_global_init(CURL_GLOBAL_DEFAULT);} ~HttpClientCurl(){ curl_global_cleanup();}
  Expected<HttpResponse> get(const std::string& url, int cto, int tto, bool follow) override {
    CURL* curl=curl_easy_init(); if(!curl) return Expected<HttpResponse>::failure("curl init failed");
    std::string body; char err[CURL_ERROR_SIZE] = {0};
    curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, cb);
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &body);
    curl_easy_setopt(curl, CURLOPT_ERRORBUFFER, err);
    curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT, cto);
    curl_easy_setopt(curl, CURLOPT_TIMEOUT, tto);
    curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, follow ? 1L : 0L);
    curl_easy_setopt(curl, CURLOPT_USERAGENT, "mytorrent/0.1");
    auto res=curl_easy_perform(curl); long code=0; curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &code); curl_easy_cleanup(curl);
    if(res!=CURLE_OK) return Expected<HttpResponse>::failure(std::string("curl error: ") + (err[0]?err:curl_easy_strerror(res)));
    if(code>=400) return Expected<HttpResponse>::failure("HTTP status "+std::to_string(code));
    return Expected<HttpResponse>::success(HttpResponse{(int)code,std::move(body)});
  }
};

// Factory helper (link this TU) — simple accessor for production
std::unique_ptr<IHttpClient> makeCurlClient(){ return std::make_unique<HttpClientCurl>(); }

} // namespace bittorrent::tracker


//// file: include/bittorrent/tracker/http_tracker.hpp
#pragma once
#include <string>
#include <string_view>
#include <memory>
#include "bittorrent/tracker/iclient.hpp"
#include "bittorrent/tracker/http_client.hpp"

namespace bittorrent::tracker {

struct HttpTrackerConfig {
  int connectTimeoutSec{8};
  int transferTimeoutSec{10};
  bool followRedirects{true};
};

class HttpTracker : public ITrackerClient {
public:
  explicit HttpTracker(std::shared_ptr<IHttpClient> http, HttpTrackerConfig cfg = {});
  ~HttpTracker() override = default;

  Expected<AnnounceResponse> announce(const AnnounceRequest& req, const std::string& announceUrl) override;
  Expected<std::map<InfoHash, ScrapeStats>> scrape(const std::vector<InfoHash>& hashes,
                                                   const std::string& scrapeUrl) override;
private:
  std::shared_ptr<IHttpClient> http_;
  HttpTrackerConfig cfg_{};
  std::string buildAnnounceUrl(const std::string& base, const AnnounceRequest& req) const;
  static std::string percentEncode(std::string_view raw);
  static std::string percentEncodeBinary(const unsigned char* data, std::size_t len);
  Expected<AnnounceResponse> parseAnnounceBody(const std::string& body) const;
  Expected<std::map<InfoHash, ScrapeStats>> parseScrapeBody(const std::string& body) const;
};

// Factory (implemented in http_client_curl.cpp)
std::unique_ptr<IHttpClient> makeCurlClient();

} // namespace bittorrent::tracker


//// file: src/bittorrent/tracker/http_tracker.cpp
#include <cstring>
#include <sstream>
#include <vector>
#include "bittorrent/tracker/http_tracker.hpp"
#include "bittorrent/tracker/compact_peer_codec.hpp"
#include "bencode/bencode.hpp"

namespace bittorrent::tracker {

HttpTracker::HttpTracker(std::shared_ptr<IHttpClient> http, HttpTrackerConfig cfg)
  : http_(std::move(http)), cfg_(cfg) {}

std::string HttpTracker::percentEncode(std::string_view raw) {
  std::ostringstream oss;
  for (unsigned char c : raw) {
    if ((c>='A'&&c<='Z')||(c>='a'&&c<='z')||(c>='0'&&c<='9')||c=='-'||c=='_'||c=='.'||c=='~') oss<<c; else {
      oss<<'%'<<std::uppercase<<std::hex<<std::setw(2)<<std::setfill('0')<<(int)c<<std::nouppercase<<std::dec;
    }
  }
  return oss.str();
}

std::string HttpTracker::percentEncodeBinary(const unsigned char* data, std::size_t len) {
  return percentEncode(std::string_view(reinterpret_cast<const char*>(data), len));
}

std::string HttpTracker::buildAnnounceUrl(const std::string& base, const AnnounceRequest& req) const {
  std::ostringstream url; url << base; if (base.find('?')==std::string::npos) url<<'?'; else url<<'&';
  url << "info_hash=" << percentEncodeBinary(req.infoHash.bytes.data(), req.infoHash.bytes.size());
  url << "&peer_id=" << percentEncodeBinary(req.peerId.bytes.data(), req.peerId.bytes.size());
  url << "&port=" << req.port;
  url << "&uploaded=" << req.uploaded;
  url << "&downloaded=" << req.downloaded;
  url << "&left=" << req.left;
  if (req.event != AnnounceEvent::none) {
    const char* e = (req.event == AnnounceEvent::started) ? "started" : (req.event == AnnounceEvent::completed ? "completed" : "stopped");
    url << "&event=" << e;
  }
  url << "&compact=" << (req.compact ? 1 : 0);
  url << "&numwant=" << req.numwant;
  url << "&key=" << req.key;
  if (req.no_peer_id) url << "&no_peer_id=1";
  if (req.ipv6) url << "&ipv6=" << percentEncode(*req.ipv6);
  if (req.trackerId) url << "&trackerid=" << percentEncode(*req.trackerId);
  return url.str();
}

Expected<AnnounceResponse> HttpTracker::parseAnnounceBody(const std::string& body) const {
  using namespace bencode;
  BencodeValue root = BencodeParser::parse(std::string_view(body));
  if (!root.isDict()) return Expected<AnnounceResponse>::failure("announce body not a dict");
  const auto& dict = root.asDict();
  if (auto it = dict.find("failure reason"); it!=dict.end() && it->second.isString())
    return Expected<AnnounceResponse>::failure(it->second.asString());

  AnnounceResponse resp;
  if (auto it = dict.find("interval"); it!=dict.end() && it->second.isInt()) resp.interval = (std::uint32_t)it->second.asInt();
  if (auto it = dict.find("min interval"); it!=dict.end() && it->second.isInt()) resp.minInterval = (std::uint32_t)it->second.asInt();
  if (auto it = dict.find("complete"); it!=dict.end() && it->second.isInt()) resp.complete = (std::uint32_t)it->second.asInt();
  if (auto it = dict.find("incomplete"); it!=dict.end() && it->second.isInt()) resp.incomplete = (std::uint32_t)it->second.asInt();
  if (auto it = dict.find("warning message"); it!=dict.end() && it->second.isString()) resp.warning = it->second.asString();
  if (auto it = dict.find("tracker id"); it!=dict.end() && it->second.isString()) resp.trackerId = it->second.asString();

  if (auto it = dict.find("peers"); it!=dict.end()) {
    if (it->second.isString()) {
      const auto& s = it->second.asString();
      auto v4 = CompactPeerCodec::parseIPv4(std::string_view(s));
      resp.peers.insert(resp.peers.end(), v4.begin(), v4.end());
    } else if (it->second.isList()) {
      for (auto const& item : it->second.asList()) {
        if (!item.isDict()) continue; const auto& d = item.asDict(); PeerAddr pa;
        if (auto ipIt = d.find("ip"); ipIt!=d.end() && ipIt->second.isString()) pa.ip = ipIt->second.asString();
        if (auto pIt = d.find("port"); pIt!=d.end() && pIt->second.isInt()) pa.port = (std::uint16_t)pIt->second.asInt();
        resp.peers.push_back(std::move(pa));
      }
    }
  }
  if (auto it = dict.find("peers6"); it!=dict.end() && it->second.isString()) {
    const auto& s = it->second.asString(); auto v6 = CompactPeerCodec::parseIPv6(std::string_view(s));
    resp.peers.insert(resp.peers.end(), v6.begin(), v6.end());
  }
  return Expected<AnnounceResponse>::success(std::move(resp));
}

Expected<std::map<InfoHash, ScrapeStats>> HttpTracker::parseScrapeBody(const std::string& body) const {
  using namespace bencode;
  BencodeValue root = BencodeParser::parse(std::string_view(body));
  if (!root.isDict()) return Expected<std::map<InfoHash, ScrapeStats>>::failure("scrape body not a dict");
  const auto& d = root.asDict();
  auto filesIt = d.find("files");
  if (filesIt == d.end() || !filesIt->second.isDict())
    return Expected<std::map<InfoHash, ScrapeStats>>::failure("scrape has no files dict");
  std::map<InfoHash, ScrapeStats> out;
  for (auto const& [k, v] : filesIt->second.asDict()) {
    if (!v.isDict()) continue;
    ScrapeStats s{}; const auto& sd = v.asDict();
    if (auto it=sd.find("complete");   it!=sd.end() && it->second.isInt()) s.complete   = (std::uint32_t)it->second.asInt();
    if (auto it=sd.find("downloaded"); it!=sd.end() && it->second.isInt()) s.downloaded = (std::uint32_t)it->second.asInt();
    if (auto it=sd.find("incomplete"); it!=sd.end() && it->second.isInt()) s.incomplete = (std::uint32_t)it->second.asInt();
    if (auto it=sd.find("name");       it!=sd.end() && it->second.isString()) s.name = it->second.asString();
    InfoHash ih{}; if (k.size()==20) std::memcpy(ih.bytes.data(), k.data(), 20); out.emplace(ih, s);
  }
  return Expected<std::map<InfoHash, ScrapeStats>>::success(std::move(out));
}

Expected<AnnounceResponse> HttpTracker::announce(const AnnounceRequest& req, const std::string& announceUrl) {
  auto url = buildAnnounceUrl(announceUrl, req);
  auto resp = http_->get(url, cfg_.connectTimeoutSec, cfg_.transferTimeoutSec, cfg_.followRedirects);
  if (!resp.has_value()) return Expected<AnnounceResponse>::failure(resp.error->message);
  return parseAnnounceBody(resp.get().body);
}

Expected<std::map<InfoHash, ScrapeStats>> HttpTracker::scrape(const std::vector<InfoHash>&, const std::string& scrapeUrl) {
  auto resp = http_->get(scrapeUrl, cfg_.connectTimeoutSec, cfg_.transferTimeoutSec, cfg_.followRedirects);
  if (!resp.has_value()) return Expected<std::map<InfoHash, ScrapeStats>>::failure(resp.error->message);
  return parseScrapeBody(resp.get().body);
}

} // namespace bittorrent::tracker


//// file: include/bittorrent/tracker/udp_tracker.hpp
#pragma once
#include "bittorrent/tracker/iclient.hpp"

namespace bittorrent::tracker {

class UdpTracker : public ITrackerClient {
public:
  Expected<AnnounceResponse> announce(const AnnounceRequest& req, const std::string& announceUrl) override {
    (void)req; (void)announceUrl;
    return Expected<AnnounceResponse>::failure("UDP tracker not implemented yet");
  }
  Expected<std::map<InfoHash, ScrapeStats>> scrape(const std::vector<InfoHash>&, const std::string&) override {
    return Expected<std::map<InfoHash, ScrapeStats>>::failure("UDP scrape not implemented yet");
  }
};

} // namespace bittorrent::tracker


//// file: include/bittorrent/tracker/endpoint.hpp
#pragma once
#include <chrono>
#include <string>
#include <vector>
#include <optional>
#include "bittorrent/tracker/types.hpp"

namespace bittorrent::tracker {

struct TrackerEndpoint {
  std::string url; // full announce URL or udp URL
  Scheme scheme{Scheme::http};
  std::chrono::steady_clock::time_point lastAnnounce{};
  std::chrono::steady_clock::time_point nextAllowed{};
  std::uint32_t failureCount{0};
  bool disabled{false};
  std::optional<std::string> trackerId;

  void recordSuccess(std::uint32_t interval, std::optional<std::uint32_t> minInterval);
  void recordFailure();
  bool canAnnounceNow(std::chrono::steady_clock::time_point now) const;
};

struct TrackerTier {
  std::vector<TrackerEndpoint> endpoints;
  std::size_t currentIndex{0};

  TrackerEndpoint& current();
  void rotate();
  bool anyAvailable(std::chrono::steady_clock::time_point now) const;
};

} // namespace bittorrent::tracker


//// file: src/bittorrent/tracker/endpoint.cpp
#include <algorithm>
#include <random>
#include "bittorrent/tracker/endpoint.hpp"

namespace bittorrent::tracker {

static std::chrono::seconds clampInterval(std::uint32_t t) {
  constexpr std::uint32_t MIN = 30;     // floor 30s
  constexpr std::uint32_t MAX = 3600;   // cap 1h for scheduling
  if (t < MIN) t = MIN;
  if (t > MAX) t = MAX;
  return std::chrono::seconds(t);
}

void TrackerEndpoint::recordSuccess(std::uint32_t interval, std::optional<std::uint32_t> minInterval) {
  lastAnnounce = std::chrono::steady_clock::now();
  auto base = minInterval.value_or(interval);
  auto dur = clampInterval(base);
  // add simple jitter ±20%
  auto jitter = static_cast<int>(dur.count() * 0.2);
  std::random_device rd; std::mt19937 gen(rd());
  std::uniform_int_distribution<int> d(-jitter, jitter);
  auto next = dur + std::chrono::seconds(d(gen));
  nextAllowed = lastAnnounce + (next < std::chrono::seconds(1) ? std::chrono::seconds(1) : next);
  failureCount = 0;
}

void TrackerEndpoint::recordFailure() {
  ++failureCount;
  auto now = std::chrono::steady_clock::now();
  // exponential backoff: 5s * 2^failures, capped
  std::uint32_t base = 5u * (1u << std::min<std::uint32_t>(failureCount, 10));
  auto dur = clampInterval(base);
  nextAllowed = now + dur;
  if (failureCount > 7) {
    disabled = true; // optional policy
  }
}

bool TrackerEndpoint::canAnnounceNow(std::chrono::steady_clock::time_point now) const {
  if (disabled) return false;
  if (nextAllowed.time_since_epoch().count() == 0) return true; // never scheduled
  return now >= nextAllowed;
}

TrackerEndpoint& TrackerTier::current() {
  if (endpoints.empty()) throw std::runtime_error("empty tracker tier");
  if (currentIndex >= endpoints.size()) currentIndex = 0;
  return endpoints[currentIndex];
}

void TrackerTier::rotate() {
  if (endpoints.empty()) return;
  currentIndex = (currentIndex + 1) % endpoints.size();
}

bool TrackerTier::anyAvailable(std::chrono::steady_clock::time_point now) const {
  for (auto const& ep : endpoints) if (ep.canAnnounceNow(now)) return true;
  return false;
}

} // namespace bittorrent::tracker


//// file: include/bittorrent/tracker/compact_peer_codec.hpp
#pragma once
#include <string>
#include <string_view>
#include <vector>
#include "bittorrent/tracker/types.hpp"

namespace bittorrent::tracker {

struct CompactPeerCodec {
  static std::vector<PeerAddr> parseIPv4(std::string_view raw);
  static std::vector<PeerAddr> parseIPv6(std::string_view raw);
};

} // namespace bittorrent::tracker


//// file: src/bittorrent/tracker/compact_peer_codec.cpp
#include <arpa/inet.h>
#include <cstring>
#include "bittorrent/tracker/compact_peer_codec.hpp"

namespace bittorrent::tracker {

static std::vector<PeerAddr> parseCompact(std::string_view raw, int elemBytes) {
  std::vector<PeerAddr> out;
  if (elemBytes != 6 && elemBytes != 18) return out;
  const std::size_t n = raw.size() / elemBytes;
  out.reserve(n);
  const unsigned char* p = reinterpret_cast<const unsigned char*>(raw.data());
  for (std::size_t i = 0; i < n; ++i) {
    PeerAddr pa;
    char buf[INET6_ADDRSTRLEN] = {0};
    if (elemBytes == 6) {
      if (!inet_ntop(AF_INET, p + i*6, buf, sizeof(buf))) continue;
      pa.ip = buf;
      std::uint16_t port;
      std::memcpy(&port, p + i*6 + 4, 2);
      pa.port = ntohs(port);
    } else {
      if (!inet_ntop(AF_INET6, p + i*18, buf, sizeof(buf))) continue;
      pa.ip = buf;
      std::uint16_t port;
      std::memcpy(&port, p + i*18 + 16, 2);
      pa.port = ntohs(port);
    }
    out.push_back(std::move(pa));
  }
  return out;
}

std::vector<PeerAddr> CompactPeerCodec::parseIPv4(std::string_view raw) {
  if (raw.size() % 6 != 0) return {};
  return parseCompact(raw, 6);
}

std::vector<PeerAddr> CompactPeerCodec::parseIPv6(std::string_view raw) {
  if (raw.size() % 18 != 0) return {};
  return parseCompact(raw, 18);
}

} // namespace bittorrent::tracker


//// file: include/bittorrent/tracker/manager.hpp
#pragma once
#include <atomic>
#include <functional>
#include <memory>
#include <mutex>
#include <thread>
#include <vector>
#include "bittorrent/tracker/types.hpp"
#include "bittorrent/tracker/endpoint.hpp"
#include "bittorrent/tracker/http_tracker.hpp"
#include "bittorrent/tracker/udp_tracker.hpp"

namespace bittorrent::tracker {

class TrackerManager {
public:
  using PeersCallback = std::function<void(const std::vector<PeerAddr>&)>;

  TrackerManager(const std::vector<std::vector<std::string>>& announceList,
                 InfoHash ih, PeerID pid, std::uint16_t port,
                 std::shared_ptr<IHttpClient> httpClient = nullptr);
  ~TrackerManager();

  void start();
  void stop();

  void onStats(std::uint64_t uploaded, std::uint64_t downloaded, std::uint64_t left);
  void announce(AnnounceEvent ev = AnnounceEvent::none, std::uint32_t numwant = 50);

  std::vector<PeerAddr> drainNewPeers();
  void setPeersCallback(PeersCallback cb);

private:
  InfoHash infoHash_{};
  PeerID peerId_{};
  std::uint16_t port_{};

  std::uint64_t uploaded_{0}, downloaded_{0}, left_{0};
  std::mutex statsMu_;

  std::vector<TrackerTier> tiers_;

  std::unique_ptr<HttpTracker> http_;
  std::unique_ptr<UdpTracker> udp_;

  std::vector<PeerAddr> pendingPeers_;
  std::mutex peersMu_;
  PeersCallback peersCb_{};

  std::thread worker_;
  std::atomic<bool> running_{false};

  void workerLoop();
  void tryOneTier(TrackerTier& tier, AnnounceEvent ev, std::uint32_t numwant);
  ITrackerClient& clientFor(const TrackerEndpoint& ep);
  AnnounceRequest makeReq(AnnounceEvent ev, std::uint32_t numwant) const;
  void deliverPeers(const std::vector<PeerAddr>& peers);
};

} // namespace bittorrent::tracker


//// file: src/bittorrent/tracker/manager.cpp
#include <chrono>
#include <regex>
#include "bittorrent/tracker/manager.hpp"

namespace bittorrent::tracker {

static Scheme detectScheme(const std::string& url) {
  if (url.rfind("udp://", 0) == 0) return Scheme::udp;
  if (url.rfind("https://", 0) == 0) return Scheme::https;
  return Scheme::http;
}

static std::string makeScrapeUrl(const std::string& announceUrl) {
  return std::regex_replace(announceUrl, std::regex("/announce(?![^/])"), "/scrape");
}

TrackerManager::TrackerManager(const std::vector<std::vector<std::string>>& announceList,
                               InfoHash ih, PeerID pid, std::uint16_t port,
                               std::shared_ptr<IHttpClient> httpClient)
  : infoHash_(ih), peerId_(pid), port_(port) {
  if (!httpClient) httpClient = makeCurlClient();
  http_ = std::make_unique<HttpTracker>(std::move(httpClient));
  udp_  = std::make_unique<UdpTracker>();

  tiers_.reserve(announceList.size());
  for (auto const& tierUrls : announceList) {
    TrackerTier tier;
    for (auto const& u : tierUrls) {
      TrackerEndpoint ep; ep.url = u; ep.scheme = detectScheme(u);
      tier.endpoints.push_back(std::move(ep));
    }
    tiers_.push_back(std::move(tier));
  }
}

TrackerManager::~TrackerManager() { stop(); }

void TrackerManager::start() {
  if (running_.exchange(true)) return;
  worker_ = std::thread([this]{ workerLoop(); });
}

void TrackerManager::stop() {
  if (!running_.exchange(false)) return;
  if (worker_.joinable()) worker_.join();
}

void TrackerManager::onStats(std::uint64_t up, std::uint64_t down, std::uint64_t left) {
  std::scoped_lock lk(statsMu_); uploaded_ = up; downloaded_ = down; left_ = left;
}

AnnounceRequest TrackerManager::makeReq(AnnounceEvent ev, std::uint32_t numwant) const {
  AnnounceRequest r; r.infoHash = infoHash_; r.peerId = peerId_; r.port = port_; r.event = ev; r.numwant = numwant; r.compact = true; r.no_peer_id = true; return r;
}

ITrackerClient& TrackerManager::clientFor(const TrackerEndpoint& ep) {
  switch (ep.scheme) { case Scheme::udp: return *udp_; case Scheme::https: [[fallthrough]]; case Scheme::http: return *http_; }
  return *http_;
}

void TrackerManager::deliverPeers(const std::vector<PeerAddr>& peers) {
  if (peersCb_) { peersCb_(peers); }
}

void TrackerManager::tryOneTier(TrackerTier& tier, AnnounceEvent ev, std::uint32_t numwant) {
  auto now = std::chrono::steady_clock::now();
  const auto startIdx = tier.currentIndex;
  for (std::size_t tries = 0; tries < tier.endpoints.size(); ++tries) {
    auto& ep = tier.current();
    if (!ep.canAnnounceNow(now)) { tier.rotate(); continue; }

    AnnounceRequest req;
    {
      std::scoped_lock lk(statsMu_);
      req = makeReq(ev, numwant);
      req.uploaded = uploaded_; req.downloaded = downloaded_; req.left = left_;
      if (ep.trackerId) req.trackerId = ep.trackerId;
    }

    auto& client = clientFor(ep);
    auto res = client.announce(req, ep.url);
    if (res.has_value()) {
      auto& a = res.get();
      ep.recordSuccess(a.minInterval.value_or(a.interval), a.minInterval);
      if (a.trackerId) ep.trackerId = a.trackerId;
      if (!a.peers.empty()) {
        {
          std::scoped_lock lk(peersMu_);
          for (auto& p : a.peers) pendingPeers_.push_back(p);
        }
        deliverPeers(a.peers);
      }
      return; // success, stop trying endpoints in this tier
    } else {
      ep.recordFailure();
      tier.rotate();
    }

    if (tier.currentIndex == startIdx) break; // full loop
  }
}

void TrackerManager::workerLoop() {
  using namespace std::chrono_literals;
  while (running_) {
    auto now = std::chrono::steady_clock::now();
    bool didWork = false;
    for (auto& tier : tiers_) {
      if (!running_) break;
      if (tier.anyAvailable(now)) { tryOneTier(tier, AnnounceEvent::none, 50); didWork = true; break; }
    }
    if (!running_) break;

    std::chrono::steady_clock::time_point earliest = now + 5s; bool haveEarliest=false;
    for (auto& tier : tiers_) {
      for (auto& ep : tier.endpoints) {
        if (ep.disabled) continue;
        if (ep.nextAllowed.time_since_epoch().count() == 0) { earliest = now + 1s; haveEarliest=true; continue; }
        if (!haveEarliest || ep.nextAllowed < earliest) { earliest = ep.nextAllowed; haveEarliest = true; }
      }
    }
    auto sleepDur = 1s; if (haveEarliest) { now = std::chrono::steady_clock::now(); sleepDur = (earliest > now) ? (earliest - now) : 1s; }
    std::this_thread::sleep_for(sleepDur);
  }
}

std::vector<PeerAddr> TrackerManager::drainNewPeers() {
  std::scoped_lock lk(peersMu_); std::vector<PeerAddr> out; out.swap(pendingPeers_); return out;
}

void TrackerManager::announce(AnnounceEvent ev, std::uint32_t numwant) {
  for (auto& tier : tiers_) { if (tier.anyAvailable(std::chrono::steady_clock::now())) { tryOneTier(tier, ev, numwant); return; } }
}

void TrackerManager::setPeersCallback(PeersCallback cb) { peersCb_ = std::move(cb); }

} // namespace bittorrent::tracker


//// file: include/bittorrent/session/torrent_session_hooks.hpp
#pragma once
#include <vector>
#include "bittorrent/tracker/manager.hpp"

namespace bittorrent {

// Minimal adapter showing how TorrentSession could hook into TrackerManager
struct TorrentSessionHooks {
  static void onTrackerPeers(const std::vector<tracker::PeerAddr>& peers);
  static void onTrackerInterval(uint32_t seconds);
};

} // namespace bittorrent


//// file: src/bittorrent/session/torrent_session_hooks.cpp
#include <iostream>
#include "bittorrent/session/torrent_session_hooks.hpp"

namespace bittorrent {

void TorrentSessionHooks::onTrackerPeers(const std::vector<tracker::PeerAddr>& peers) {
  std::cout << "[TorrentSession] received " << peers.size() << " peers from tracker
";
  for (auto const& p : peers) {
    // TODO: forward to PeerManager
    std::cout << "  " << p.ip << ":" << p.port << "
";
  }
}

void TorrentSessionHooks::onTrackerInterval(uint32_t seconds) {
  std::cout << "[TorrentSession] tracker suggested interval: " << seconds << "s
";
}

} // namespace bittorrent


//// file: tests/test_compact_codec.cpp
#define CATCH_CONFIG_MAIN
#include <catch2/catch.hpp>
#include "bittorrent/tracker/compact_peer_codec.hpp"

using namespace bittorrent::tracker;

TEST_CASE("parse IPv4 compact peers") {
  // two peers: 1.2.3.4:6881 and 127.0.0.1:80
  std::string raw; raw.push_back(1); raw.push_back(2); raw.push_back(3); raw.push_back(4);
  raw.push_back((char)0x1A); raw.push_back((char)0xE1); // 6881
  raw.push_back((char)127); raw.push_back((char)0); raw.push_back((char)0); raw.push_back((char)1);
  raw.push_back((char)0); raw.push_back((char)80);
  auto v = CompactPeerCodec::parseIPv4(raw);
  REQUIRE(v.size() == 2);
  REQUIRE(v[0].ip == "1.2.3.4");
  REQUIRE(v[0].port == 6881);
  REQUIRE(v[1].ip == "127.0.0.1");
  REQUIRE(v[1].port == 80);
}


//// file: tests/test_http_announce_parse.cpp
#include <catch2/catch.hpp>
#include "bittorrent/tracker/http_tracker.hpp"
#include "bencode/bencode.hpp"

using namespace bittorrent::tracker;

struct FakeHttp : IHttpClient {
  std::string body;
  Expected<HttpResponse> get(const std::string&, int, int, bool) override { return Expected<HttpResponse>::success({200, body}); }
};

TEST_CASE("announce parse success with compact peers") {
  // bencoded dict: interval=1800, complete=10, incomplete=5, peers=6-byte*1 for 1.2.3.4:6881
  std::string peers; peers.push_back(1); peers.push_back(2); peers.push_back(3); peers.push_back(4); peers.push_back((char)0x1A); peers.push_back((char)0xE1);
  bencode::BencodeValue root = bencode::BencodeValue(std::map<std::string,bencode::BencodeValue>{
    {"interval", bencode::BencodeValue((int64_t)1800)},
    {"complete", bencode::BencodeValue((int64_t)10)},
    {"incomplete", bencode::BencodeValue((int64_t)5)},
    {"peers", bencode::BencodeValue(peers)}
  });
  std::string body = bencode::BencodeParser::encode(root); // assuming you have encode; else craft raw

  auto http = std::make_shared<FakeHttp>(); http->body = body;
  HttpTracker t(http);
  AnnounceRequest req{}; req.infoHash = {}; req.peerId = {}; req.port = 51413; req.numwant = 1;
  auto resp = t.announce(req, "http://x/announce");
  REQUIRE(resp.has_value());
  REQUIRE(resp.get().peers.size() == 1);
  REQUIRE(resp.get().peers[0].ip == "1.2.3.4");
  REQUIRE(resp.get().peers[0].port == 6881);
}


//// file: tests/test_manager_callback.cpp
#include <catch2/catch.hpp>
#include "bittorrent/tracker/manager.hpp"

using namespace bittorrent::tracker;

struct FakeHttp2 : IHttpClient {
  Expected<HttpResponse> get(const std::string& url, int, int, bool) override {
    // return a minimal valid announce body once
    static int calls=0; ++calls; (void)url;
    std::string peers; peers.push_back(1); peers.push_back(1); peers.push_back(1); peers.push_back(1); peers.push_back((char)0x1A); peers.push_back((char)0xE1);
    std::string body = "d8:completei1e10:incompletei2e8:intervali30e5:peers" + std::to_string(peers.size()) + ":" + peers + "e";
    return Expected<HttpResponse>::success({200, body});
  }
};

TEST_CASE("manager delivers peers via callback and drain") {
  std::vector<std::vector<std::string>> al = {{"http://t/announce"}};
  InfoHash ih{}; PeerID pid{}; TrackerManager m(al, ih, pid, 51413, std::make_shared<FakeHttp2>());
  std::vector<PeerAddr> got;
  m.setPeersCallback([&](const std::vector<PeerAddr>& v){ got = v; });
  m.start(); m.onStats(0,0,1000); m.announce(AnnounceEvent::started, 1);
  std::this_thread::sleep_for(std::chrono::milliseconds(100));
  m.stop();
  REQUIRE(!got.empty());
  auto drained = m.drainNewPeers();
  REQUIRE(!drained.empty());
}


//// file: tests/CMakeLists.txt
# Assumes Catch2 is available (FetchContent or find_package)
# Example using FetchContent (CMake 3.14+)
include(FetchContent)
FetchContent_Declare(
  catch2
  GIT_REPOSITORY https://github.com/catchorg/Catch2.git
  GIT_TAG v3.6.0
)
FetchContent_MakeAvailable(catch2)

add_executable(test_compact tests/test_compact_codec.cpp)
add_executable(test_http_parse tests/test_http_announce_parse.cpp)
add_executable(test_manager_cb tests/test_manager_callback.cpp)

foreach(tgt IN ITEMS test_compact test_http_parse test_manager_cb)
  target_link_libraries(${tgt} PRIVATE tracker Catch2::Catch2WithMain)
  target_compile_features(${tgt} PRIVATE cxx_std_20)
endforeach()

add_test(NAME test_compact COMMAND test_compact)
add_test(NAME test_http_parse COMMAND test_http_parse)
add_test(NAME test_manager_cb COMMAND test_manager_cb)


//// file: tests/README.md
# Tests
- `test_compact` validates IPv4 compact peer parsing.
- `test_http_parse` validates announce response parsing from a fake HTTP client.
- `test_manager_cb` spins up `TrackerManager` with a fake HTTP client and ensures peers are delivered via callback and drain API.


//// file: tests/tracker_min_smoke.cpp
// (Optional) Minimal smoke usage — replace with your real test framework.
#include <iostream>
#include "bittorrent/tracker/manager.hpp"
#include "bittorrent/session/torrent_session_hooks.hpp"

using namespace bittorrent::tracker;

int main() {
  std::vector<std::vector<std::string>> announceList = {
    {"https://tracker.opentrackr.org:443/announce"}
  };
  InfoHash ih{}; PeerID pid{};
  TrackerManager mgr(announceList, ih, pid, 51413);
  mgr.setPeersCallback([](const std::vector<PeerAddr>& peers){ bittorrent::TorrentSessionHooks::onTrackerPeers(peers); });
  mgr.start(); mgr.onStats(0,0,12345); mgr.announce(AnnounceEvent::started, 50);
  std::this_thread::sleep_for(std::chrono::seconds(1));
  auto peers = mgr.drainNewPeers();
  std::cout << "Peers fetched: " << peers.size() << "
";
  mgr.stop();
  return 0;
}


//// file: CMakeLists.additions.txt
# Add these to your project CMakeLists (adjust paths as needed)
# Requires libcurl and your bencode lib target (e.g., bencode)

find_package(CURL REQUIRED)

add_library(tracker
  src/bittorrent/tracker/types.cpp
  src/bittorrent/tracker/endpoint.cpp
  src/bittorrent/tracker/compact_peer_codec.cpp
  src/bittorrent/tracker/http_client_curl.cpp
  src/bittorrent/tracker/http_tracker.cpp
  src/bittorrent/tracker/manager.cpp
  src/bittorrent/session/torrent_session_hooks.cpp
)

target_include_directories(tracker PUBLIC include)

target_link_libraries(tracker
  PRIVATE CURL::libcurl
  PUBLIC bencode
)

# Example test executables — and Catch2 via FetchContent inside tests/CMakeLists.txt
add_executable(tracker_min_smoke tests/tracker_min_smoke.cpp)

target_link_libraries(tracker_min_smoke PRIVATE tracker)

# Enable CTest
include(CTest)
add_subdirectory(tests)
